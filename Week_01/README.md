## 学习笔记

### 算法题最大误区：只做一遍！！！

### 五毒神掌
1. 5-10 分钟读题和思考，如果没有思路，看题解，默写代码
1. 马上自己写，提交LeetCode，多种解法，体会优化
1. 24 小时之后，再重复做题
1. 一周后重复做题
1. 面试前一周恢复性训练

### 切题四件套
1. 理清题意，确定题目的要求
2. 想尽可能多的解法，对比几种写法的时空复杂度，找到比较好的解法
3. 尽可能多地动手写
4. 测试用例

#### 一维数据结构
1. 数组 array，查询速度快，时间复杂度O(1)，删除、添加的速度慢，时间复杂度O(n)。
2. 链表 linked list，查询速度慢，时间复杂度O(n)；删除、添加的速度快，时间复杂度O(1)。
3. 栈 stack, 先进后出 FILO，查询速度为O(n)；删除、添加的速度快，时间复杂度O(1)。
4. 队列 queue，先进先出，FIFO，查询速度为O(n)；删除、添加的速度快，时间复杂度O(1)。
5. 双端队列 deque, queue 和 stack 的结合体，头和尾都可以进行元素的push和pop，查询速度为O(n)，删除、添加速度为O(1)。
6. 集合 set,
7. hash表 map,

#### 二维数据结构
1. 树 tree,
2. 图 graph,
3. 二叉搜索树 binary search tree,
4. 堆 heap,
5. 并查集 disjoint set,
6. 字典树

#### 特殊数据结构
1. 位运算 Bitwise,
2. 布隆过滤器 Bloom Fiilter,
3. LruChache

## 数组和链表时间复杂度
|  操作   |  数组 |  链表  |
|  ----  | ----  |  ---   |
| prepend| o(1)  |  o(1)  |
| append | o(1)  |  o(1)  |
| lookup | o(1)  |  o(n)  |
| insert | o(n)  |  o(1)  |
| delete | o(n)  |  o(1)  |

##### 1.1 数组
连续内存块，在插入，删除过程中需要移动对应位置的后面所有元素，具有o(n)复杂度。在对应位置查找中具有o(1)复杂度。

在高级语言中的数组，一般至少含有原始数组及size及cap三个成员变量，当size==cap后继续append，需要分配更大的连续内存存放数据
以及复制原有数据到新的内存空间中再继续后续的append操作，意味着数组初始化容量太小，会有多次扩容复制以及内存垃圾的产生，因此
尽量在使用的过程中确定数组的size范围来初始化数组

数组相较链表，内存位置连续，这样更有可能利用上cpu cache，例如同样从0->n的遍历，数组要比链表快

虽然数组具有高速访问数据的特性，但是删除上的性能过低，无法直接用于当做队列结构，可以封装成环来充当队列

#### 1.2 链表
链表的处理尽量加上哨兵来简化操作

#### 1.3 跳表
跳表主要麻烦在插入，删除节点的处理，处理不好会导致导致高层节点间的元素不均衡，会导致查询时间复杂度退化到o(n)

### 一些思想
+ 写代码要采用自顶向下的编程方式，即先写主干逻辑，再写具体实现；
+ 双指针的算法一般要先进行排序；
+ 一维数据要加速可以通过升维度，如 有序的链表升为跳表；

## 转载：
https://github.com/wentianyang/algorithm016/blob/master/Week_01/README.md
https://github.com/RainAlways/algorithm016/tree/master/Week_01